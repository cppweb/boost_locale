<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Boost.Locale</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><style type="text/css"
    >
ol.decimal { list-style-type: decimal; }
</style
    ><link rel="stylesheet" href="../../../doc/html/boostbook.css" type="text/css" media="all" />
</head
  ><body
  ><div id="toc"
    ><ul
      ><li
	><a href="#introduction" id="TOC-introduction"
	  >Introduction</a
	  ></li
	><li
	><a href="#tutorial" id="TOC-tutorial"
	  >Tutorial</a
	  ><ul
	  ><li
	    ><a href="#locale-generation" id="TOC-locale-generation"
	      >Locale Generation</a
	      ></li
	    ><li
	    ><a href="#collation" id="TOC-collation"
	      >Collation</a
	      ></li
	    ><li
	    ><a href="#conversions" id="TOC-conversions"
	      >Conversions</a
	      ></li
	    ><li
	    ><a href="#numbers-time-and-currency-formatting-and-parsing" id="TOC-numbers-time-and-currency-formatting-and-parsing"
	      >Numbers, Time and Currency formatting and parsing</a
	      ><ul
	      ><li
		><a href="#numbers-and-number-manipulators" id="TOC-numbers-and-number-manipulators"
		  >Numbers and number manipulators</a
		  ></li
		><li
		><a href="#currency-formatting" id="TOC-currency-formatting"
		  >Currency formatting</a
		  ></li
		><li
		><a href="#date-and-time-formatting" id="TOC-date-and-time-formatting"
		  >Date and Time formatting</a
		  ></li
		><li
		><a href="#internals" id="TOC-internals"
		  >Internals</a
		  ></li
		></ul
	      ></li
	    ><li
	    ><a href="#messages-formatting" id="TOC-messages-formatting"
	      >Messages Formatting</a
	      ><ul
	      ><li
		><a href="#introduction-1" id="TOC-introduction-1"
		  >Introduction</a
		  ></li
		><li
		><a href="#loading-dictionaries" id="TOC-loading-dictionaries"
		  >Loading dictionaries</a
		  ></li
		><li
		><a href="#message-translation" id="TOC-message-translation"
		  >Message Translation</a
		  ></li
		><li
		><a href="#plural-forms" id="TOC-plural-forms"
		  >Plural Forms</a
		  ></li
		><li
		><a href="#adding-context-information" id="TOC-adding-context-information"
		  >Adding context information</a
		  ></li
		><li
		><a href="#working-with-multiple-messages-domains" id="TOC-working-with-multiple-messages-domains"
		  >Working with multiple messages domains</a
		  ></li
		><li
		><a href="#questions-and-answers" id="TOC-questions-and-answers"
		  >Questions and Answers</a
		  ></li
		></ul
	      ></li
	    ><li
	    ><a href="#code-page-conversions" id="TOC-code-page-conversions"
	      >Code-page conversions</a
	      ></li
	    ><li
	    ><a href="#boundary-analysis" id="TOC-boundary-analysis"
	      >Boundary analysis</a
	      ></li
	    ><li
	    ><a href="#localized-text-formatting" id="TOC-localized-text-formatting"
	      >Localized Text Formatting</a
	      ></li
	    ><li
	    ><a href="#getting-information-about-current-locale" id="TOC-getting-information-about-current-locale"
	      >Getting information about current locale</a
	      ></li
	    ><li
	    ><a href="#working-with-multiple-locales" id="TOC-working-with-multiple-locales"
	      >Working with multiple locales</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#recommendations-and-myths" id="TOC-recommendations-and-myths"
	  >Recommendations and Myths</a
	  ><ul
	  ><li
	    ><a href="#recommendations" id="TOC-recommendations"
	      >Recommendations</a
	      ></li
	    ><li
	    ><a href="#myths" id="TOC-myths"
	      >Myths</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#design-rationale" id="TOC-design-rationale"
	  >Design Rationale</a
	  ></li
	></ul
      ></div
    ><!--
 vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 filetype=mkd
-->
<h1 id="introduction"
    ><a href="#TOC-introduction"
      >Introduction</a
      ></h1
    ><p
    >Boost.Locale is a library that brings high quality localization facilities in C++ way. It uses <code
      >std::locale</code
      >, and <code
      >std::locale</code
      > facets in order to provide localization in transparent and C++ aware way to user.</p
    ><p
    >C++ has quite a good base for localization via existing C++ locale facets: <code
      >std::num_put</code
      >, <code
      >std::ctype</code
      >, <code
      >std::collate</code
      > etc.. But they are very limited and sometimes buggy by design. The support of localization varies between different operating systems and incompatible between them.</p
    ><p
    >On the other hand, there is great, well debugged, high quality, widely used ICU library that gives all of the goodies but, it has very old API that mimics Java behavior, it completely ignores STL and provides useful API only for UTF&ndash;16 encoded text, ignoring other popular Unicode encodings like UTF&ndash;8 and UTF&ndash;32, or limited national character sets like Latin1.</p
    ><p
    >Boost.Locale provides the natural glue between C++ locales framework, iostreams and powerful ICU library in following areas:</p
    ><ul
    ><li
      >Correct case conversion, case folding and normalization</li
      ><li
      >Collation including support of 4 Unicode collation levels.</li
      ><li
      >Date and time formatting and parsing including support of timezones and calendars other then Gregorian.</li
      ><li
      >Number formatting, spelling and parsing</li
      ><li
      >Monetary formatting and parsing</li
      ><li
      >Powerful message formatting including support plural forms, using GNU catalogs.</li
      ><li
      >Character, word, sentence and line-break boundary analysis.</li
      ><li
      >Support of 8-bit character sets like Latin1 and UTF&ndash;8 encoded text.</li
      ><li
      >Support of <code
	>char</code
	>, <code
	>wchar_t</code
	> and C++0x <code
	>char16_t</code
	>, <code
	>char32_t</code
	> strings and streams.</li
      ></ul
    ><h1 id="tutorial"
    ><a href="#TOC-tutorial"
      >Tutorial</a
      ></h1
    ><h2 id="locale-generation"
    ><a href="#TOC-locale-generation"
      >Locale Generation</a
      ></h2
    ><p
    >The major &ldquo;container&rdquo; of all localization information in C++ is class <code
      >std::locale</code
      >. It is designed to hold all general information about specific culture and can be easily extended with additional resources providing information about specific area: facets. Facets are classes derived from <code
      >std::locale::facet</code
      > that hold required resources.</p
    ><p
    >Each locale is defined by specific locale identifier that contains a mandatory part&mdash;Language and optional pars Country, Variant, and keywords, when we use narrow strings (a.k.a. <code
      >std::string</code
      >) we need to specify encoding we use as well.</p
    ><p
    >First we generate our locale with all required facets and then we can use it. Class <code
      >boost::locale::generator</code
      > provides us such tool. The simplest way to use generator is to create a locale and set it as global one:</p
    ><pre
    ><code
      >#include &lt;boost/locale.hpp&gt;

using namespace boost::locale;
int main()
{
    generator gen;
    // Create locale generator 
    std::locale::global(gen(&quot;&quot;));
    // Set system default global locale
}
</code
      ></pre
    ><p
    >Of course we can specify locale manually, using default system encoding:</p
    ><pre
    ><code
      >std::locale loc = gen(&quot;en_US&quot;); 
// Use English, United States locale
</code
      ></pre
    ><p
    >Or specify both locale and encoding independently or using POSIX locale specifier that includes both locale information and encoding:</p
    ><pre
    ><code
      >std::locale loc = gen(&quot;ja_JP&quot;,&quot;UTF-8&quot;); 
// Separation of locale and encoding
std::locale loc = gen(&quot;ja_JP.UTF-8&quot;);
// POSIX locale name with encoding
</code
      ></pre
    ><p
    >When you generate more then one locale, you may specify the default encoding used for <code
      >std::string</code
      > by calling <code
      >octet_encoding</code
      > member function of <code
      >generator</code
      >. For example:</p
    ><pre
    ><code
      >generator gen;
gen.octet_encoding(&quot;UTF-8&quot;);

std::locale en=gen(&quot;en_US&quot;);
std::locale ja=gen(&quot;ja_JP&quot;);
</code
      ></pre
    ><p
    ><strong
      >Note:</strong
      > Even if your application uses wide strings anywhere it is recommended to specify 8-bit encoding that would be used for all wide stream IO operations like <code
      >wcout</code
      > or <code
      >wfstream</code
      >.</p
    ><p
    ><strong
      >Tip:</strong
      > Prefer using UTF&ndash;8 Unicode encoding over 8-bit encodings like ISO&ndash;8859-X ones.</p
    ><p
    >By default the locale generated for all supported categories and character types. However, if your application uses strictly 8-bit encodings, uses only wide character encodings only or it uses only specific parts of the localization tools you can limit facet generation to specific categories and character types, by calling <code
      >categories</code
      > and <code
      >characters</code
      > member functions of <code
      >generator</code
      > class.</p
    ><p
    >For example:</p
    ><pre
    ><code
      >generator gen;
gen.characters(wchar_t_facet);
gen.categories(collation_facet | formatting_facet);
std::locale::global(gen(&quot;de_DE.UTF-8&quot;));
</code
      ></pre
    ><h2 id="collation"
    ><a href="#TOC-collation"
      >Collation</a
      ></h2
    ><p
    >Boost.Locale provides <code
      >collator</code
      > class derived from <code
      >std::collate</code
      > that extends it with support of comparison levels: primary&mdash;the default one, secondary, tertiary and quaternary levels. They can be approximately defined as:</p
    ><ol class="decimal"
    ><li
      >Primary&mdash;ignore accents and characters&rsquo; case compare base characters only. For example &ldquo;facade&rdquo; and &ldquo;Façade&rdquo; are same.</li
      ><li
      >Secondary&mdash;ignore characters case but consider accents &ldquo;facade&rdquo; and &ldquo;façade&rdquo; are different but &ldquo;Façade&rdquo; and &ldquo;façade&rdquo; are same.</li
      ><li
      >Tertiary&mdash;do not ignore case and accents: &ldquo;Façade&rdquo; and &ldquo;façade&rdquo; are different</li
      ><li
      >Quaternary&mdash;the words are identical in terms of Unicode representation</li
      ></ol
    ><p
    >There are two ways of using <code
      >collator</code
      > facet: direct by calling its member functions <code
      >compare</code
      >, <code
      >transform</code
      > and <code
      >hash</code
      > or indirect by using <code
      >comparator</code
      > template class in STL algorithms.</p
    ><p
    >For example:</p
    ><pre
    ><code
      >wstring a=L&quot;Façade&quot;, b=L&quot;facade&quot;;
bool eq = 0 == use_facet&lt;collator&lt;wchar_t&gt; &gt;(loc).compare(collator_base::secondary,a,b);
wcout &lt;&lt; a &lt;&lt;L&quot; and &quot;&lt;&lt;b&lt;&lt;L&quot; are &quot; &lt;&lt; (eq ? L&quot;identical&quot; : L&quot;different&quot;)&lt;&lt;endl;
</code
      ></pre
    ><p
    ><code
      >std::locale</code
      > is designed to be useful as comparison class in STL collection and algorithms. In order to get similar functionality with addition of comparison levels you use comparator class.</p
    ><pre
    ><code
      >std::map&lt;std::string,std::string,comparator&lt;char,collator_base::secondary&gt; &gt; strings;
// Now strings uses default system locale for string comparison
</code
      ></pre
    ><p
    >You can also set specific locale or level when creating and using <code
      >comparator</code
      > class:</p
    ><pre
    ><code
      >comparator&lt;char&gt; comp(some_locale,some_level);
std::map&lt;std::string,std::string,comparator&lt;char&gt; &gt; strings(comp);
</code
      ></pre
    ><h2 id="conversions"
    ><a href="#TOC-conversions"
      >Conversions</a
      ></h2
    ><p
    >There is a set of function that perform basic string conversion operations: upper, lower and title case conversions, case folding and Unicode normalization. The functions are called <code
      >to_upper</code
      >, <code
      >to_lower</code
      >, <code
      >to_title</code
      >, <code
      >fold_case</code
      > and <code
      >normalize</code
      >.</p
    ><p
    >You may notice that there are existing functions <code
      >to_upper</code
      > and <code
      >to_lower</code
      > under in Boost.StringAlgo library, what is the difference? The difference is that these function operate over entire string instead of performing incorrect character-by-character conversions.</p
    ><p
    >For example:</p
    ><pre
    ><code
      >std::wstring gruben = L&quot;grüßen&quot;;
std::wcout &lt;&lt; boost::algorithm::to_upper_copy(gruben) &lt;&lt; &quot; &quot; &lt;&lt; boost::locale::to_upper(gruben) &lt;&lt; std::endl;
</code
      ></pre
    ><p
    >Would give in output:</p
    ><blockquote
    ><p
      >GRÜßEN GRÜSSEN</p
      ></blockquote
    ><p
    >Where a letter &ldquo;ß&rdquo; was not converted correctly to double-S in first case because of limitation of <code
      >std::ctype</code
      > facet.</p
    ><p
    ><strong
      >Notes:</strong
      ></p
    ><ul
    ><li
      ><code
	>normalize</code
	> operates only on Unicode encoded strings, i.e.: UTF&ndash;8, UTF&ndash;16 and UTF&ndash;32 according to the character width. So be careful when using non-UTF encodings in the program they may be treated incorrectly.</li
      ><li
      ><code
	>fold_case</code
	> is generally locale independent operation, however it receives locale as parameter in order to determinate 8-bit encoding.</li
      ><li
      >All functions can work with STL string, NUL terminated string, and a range defined by two pointers. They always return a newly created STL string.</li
      ><li
      >Length of string may be changed, see an example above.</li
      ></ul
    ><h2 id="numbers-time-and-currency-formatting-and-parsing"
    ><a href="#TOC-numbers-time-and-currency-formatting-and-parsing"
      >Numbers, Time and Currency formatting and parsing</a
      ></h2
    ><p
    >All formatting and parsing is performed via <code
      >iostream</code
      > STL library. Each one of the above information types is represented as number. The formatting information is set using iostream manipulators. All manipulators are placed in <code
      >boost::locale::as</code
      > namespace.</p
    ><p
    >For example:</p
    ><pre
    ><code
      >cout &lt;&lt; as::currency &lt;&lt; 123.45 &lt;&lt; endl;
// display 123.45 in local currency representation.
cin &gt;&gt; as::currency &gt;&gt; x ;
// Parse currency representation and store it in x
</code
      ></pre
    ><p
    >There is a special manipulator <code
      >as::posix</code
      > that unset locale specific settings and returns back to ordinary, default <code
      >iostream</code
      > formatting and parsing methods. Please note, such formats may still be localized by default <code
      >std::num_put</code
      > and <code
      >std::num_get</code
      > facets.</p
    ><h3 id="numbers-and-number-manipulators"
    ><a href="#TOC-numbers-and-number-manipulators"
      >Numbers and number manipulators</a
      ></h3
    ><p
    >These are manipulators for number formatting:</p
    ><ul
    ><li
      ><p
	><code
	  >as::number</code
	  >&mdash;format number according to local specifications, it takes in account various <code
	  >std::ios_base</code
	  > flags like scientific format and precision.</p
	></li
      ><li
      ><p
	><code
	  >as::percent</code
	  >&mdash;format number as &ldquo;percent&rdquo; format. For example:</p
	><pre
	><code
	  >cout &lt;&lt; as::percent &lt;&lt; 0.25 &lt;&lt;endl;
</code
	  ></pre
	><p
	>Would create an output that may look like this:</p
	><blockquote
	><p
	  >25%</p
	  ></blockquote
	></li
      ><li
      ><p
	><code
	  >as::spellout</code
	  >&mdash;spell the number. For example under English locale 103 may be displayed as &ldquo;one hundred three&rdquo;. <em
	  >Note:</em
	  > not all locales provide rules for spelling numbers, in such case the number would be displayed in decimal format.</p
	></li
      ><li
      ><p
	><code
	  >as::ordinal</code
	  >&mdash;display an order of element. For example &ldquo;2&rdquo; would be displayed as &ldquo;2nd&rdquo; under English locale. As in above case not all locales provide ordinal rules.</p
	></li
      ></ul
    ><h3 id="currency-formatting"
    ><a href="#TOC-currency-formatting"
      >Currency formatting</a
      ></h3
    ><p
    >These are manipulators for currency formatting:</p
    ><ul
    ><li
      ><code
	>as::currency</code
	>&mdash;set format to currency mode.</li
      ><li
      ><code
	>as::currency_iso</code
	>&mdash;change currency format to international like &ldquo;USD&rdquo; instead of &ldquo;$&rdquo;. This flag is supported when using ICU 4.2 and above.</li
      ><li
      ><code
	>as::currency_national</code
	>&mdash;change currency format to national like &ldquo;$&rdquo;.</li
      ><li
      ><code
	>as::currency_default</code
	>&mdash;return to default currency format (national)</li
      ></ul
    ><p
    >Note <code
      >as::currency_XYZ</code
      > manipulators do not affect on general formatting, but only on the format of currency, it is necessary to use both manipulators in order to use non-default format.</p
    ><h3 id="date-and-time-formatting"
    ><a href="#TOC-date-and-time-formatting"
      >Date and Time formatting</a
      ></h3
    ><p
    >Dates and times are represented as POSIX time. When date-time formatting is turned on in the <code
      >iostream</code
      >, each number is treated as POSIX time. The number may be integer, or double.</p
    ><p
    >There are four major manipulators of Date and Time formatting:</p
    ><ul
    ><li
      ><code
	>as::date</code
	>&mdash;display date only</li
      ><li
      ><code
	>as::time</code
	>&mdash;display time only</li
      ><li
      ><code
	>as::datetime</code
	>&mdash;display both date and time</li
      ><li
      ><code
	>as::ftime</code
	>&mdash;parametrized manipulator that allows specification of time in format that is used <code
	>strftime</code
	> function. <em
	>Note:</em
	> not all formatting flags of <code
	>strtftime</code
	> are supported.</li
      ></ul
    ><p
    >For example:</p
    ><pre
    ><code
      >double now=time(0);
cout &lt;&lt; &quot;Today is &quot;&lt;&lt; as::date &lt;&lt; now &lt;&lt; &quot; and tommorrow is &quot; &lt;&lt; now+24*3600 &lt;&lt; endl;
cout &lt;&lt; &quot;Current time is &quot;&lt;&lt; as::time &lt;&lt; now &lt;&lt; endl;
cout &lt;&lt; &quot;The current weekday is &quot;&lt;&lt; as::ftime(&quot;%A&quot;) &lt;&lt; now &lt;&lt; endl;
</code
      ></pre
    ><p
    >There are also more fine grained control of date-time formatting is available:</p
    ><ul
    ><li
      ><code
	>as::time_default</code
	>, <code
	>as::time_short</code
	>, <code
	>as::time_medium</code
	>, <code
	>as::time_long</code
	>, <code
	>as::time_full</code
	>&mdash;change time formatting.</li
      ><li
      ><code
	>as::date_default</code
	>, <code
	>as::date_short</code
	>, <code
	>as::date_medium</code
	>, <code
	>as::date_long</code
	>, <code
	>as::date_full</code
	>&mdash;change date formatting.</li
      ></ul
    ><p
    >These manipulators, when used together with <code
      >as::date</code
      >, <code
      >as::time</code
      >, <code
      >as::datetime</code
      > manipulators change the date-time representation. The default format is medium.</p
    ><p
    >By default, the date and time is shown in local time zone, this behavior may be changed using following manipulators:</p
    ><ul
    ><li
      ><code
	>as::gmt</code
	>&mdash;display date and time in GMT.</li
      ><li
      ><code
	>as::local_time</code
	>&mdash;display in local time format (default).</li
      ><li
      ><code
	>as::time_zone</code
	>&mdash;parametrized manipulator that sets time-zone ID for date-time formatting and parsing. It receives as parameter a string that represents time zone id or <code
	>boost::locale::time_zone</code
	> class.</li
      ></ul
    ><p
    >For example:</p
    ><pre
    ><code
      >double now=time(0);
cout &lt;&lt; as::datetime &lt;&lt; as::locale_time &lt;&lt; &quot;Locale time is: &quot;&lt;&lt; now &lt;&lt; endl;
cout &lt;&lt; as::gmt &lt;&lt; &quot;GMT Time is: &quot;&lt;&lt; now &lt;&lt;endl;
cout &lt;&lt; as::time_zone(&quot;EST&quot;) &lt;&lt; &quot;Eastern Standard Time is: &quot;&lt;&lt; now &lt;&lt;endl;
</code
      ></pre
    ><p
    >The list of all available time zone IDs can be received as <code
      >set&lt;string&gt;</code
      > using <code
      >all_zones</code
      > static member function of <code
      >boost::locale::time_zone</code
      > class.</p
    ><p
    >There is a list of supported <code
      >strftime</code
      > flags:</p
    ><ul
    ><li
      ><code
	>%a</code
	>&mdash;Abbreviated weekday (Sun.)</li
      ><li
      ><code
	>%A</code
	>&mdash;Full weekday (Sunday)</li
      ><li
      ><code
	>%b</code
	>&mdash;Abbreviated month (Jan.)</li
      ><li
      ><code
	>%B</code
	>&mdash;Full month (January)</li
      ><li
      ><code
	>%c</code
	>&mdash;Locale date-time format. <strong
	>Note:</strong
	> prefer using <code
	>as::datetime</code
	></li
      ><li
      ><code
	>%d</code
	>&mdash;Day of Month [01,31]</li
      ><li
      ><code
	>%e</code
	>&mdash;Day of Month [1,31]</li
      ><li
      ><code
	>%h</code
	>&mdash;Same as <code
	>%b</code
	></li
      ><li
      ><code
	>%H</code
	>&mdash;24 clock hour [00,23]</li
      ><li
      ><code
	>%I</code
	>&mdash;12 clock hour [01,12]</li
      ><li
      ><code
	>%j</code
	>&mdash;Day of year [1,366]</li
      ><li
      ><code
	>%m</code
	>&mdash;Month [01,12]</li
      ><li
      ><code
	>%M</code
	>&mdash;Minute [00,59]</li
      ><li
      ><code
	>%n</code
	>&mdash;New Line</li
      ><li
      ><code
	>%p</code
	>&mdash;AM/PM in locale representation</li
      ><li
      ><code
	>%r</code
	>&mdash;Time with AM/PM, same as <code
	>%I:%M:%S %p</code
	></li
      ><li
      ><code
	>%R</code
	>&mdash;Same as <code
	>%H:%M</code
	></li
      ><li
      ><code
	>%S</code
	>&mdash;Second [00,61]</li
      ><li
      ><code
	>%t</code
	>&mdash;Tab character</li
      ><li
      ><code
	>%T</code
	>&mdash;Same as <code
	>%H:%M:%S</code
	></li
      ><li
      ><code
	>%x</code
	>&mdash;Local date representation. <strong
	>Note:</strong
	> prefer using <code
	>as::date</code
	></li
      ><li
      ><code
	>%X</code
	>&mdash;Local time representation. <strong
	>Note:</strong
	> prefer using <code
	>as::time</code
	></li
      ><li
      ><code
	>%y</code
	>&mdash;Year [00,99]</li
      ><li
      ><code
	>%Y</code
	>&mdash;4 digits year. (2009)</li
      ><li
      ><code
	>%Z</code
	>&mdash;Time Zone</li
      ><li
      ><code
	>%%</code
	>&mdash;Percent symbol</li
      ></ul
    ><p
    >Unsupported <code
      >strftime</code
      > flags are: <code
      >%C</code
      >, <code
      >%u</code
      >, <code
      >%U</code
      >, <code
      >%V</code
      >, <code
      >%w</code
      >, <code
      >%W</code
      >. Also <code
      >O</code
      > and <code
      >E</code
      > modifiers are not supported.</p
    ><p
    ><strong
      >General recommendations:</strong
      ></p
    ><ul
    ><li
      >Prefer using generic date-time manipulators rather then specifying full format using <code
	>as::ftime</code
	>.</li
      ><li
      >Remember not all used calendars are Gregorian.</li
      ></ul
    ><h3 id="internals"
    ><a href="#TOC-internals"
      >Internals</a
      ></h3
    ><p
    >All formatting information is stored in stream class by using <code
      >xalloc</code
      >, <code
      >pword</code
      >, and <code
      >register_callback</code
      > member functions of <code
      >std::ios_base</code
      >. All the information is stored and managed using special object binded to <code
      >iostream</code
      >, all manipulators just change its state.</p
    ><p
    >When a number is written to the stream or read from it. Custom Boost.Locale facet access to this object and checks required formatting information. Then it creates <code
      >boost::locale::formatter</code
      > object that actually formats the number and caches it in the <code
      >iostream</code
      >. When next time another number is written to the stream same formatter would be used unless some flags had changed and formatter object is invalid.</p
    ><p
    ><code
      >boost::locale::formatter&lt;CharType&gt;</code
      > class generally used via special facets but it can be used directly as well. It has two kinds of member functions:</p
    ><ul
    ><li
      ><code
	>std::basic_string&lt;CharType&gt; format(ValueType v,size_t &amp;code_points)</code
	>&mdash;convert a value <code
	>v</code
	> to a string and return number of Unicode code points used in the string.</li
      ><li
      ><code
	>size_t parse(std::basic_string&lt;CharType&gt; const &amp;s,ValueType &amp;b)</code
	>&mdash;parse a value from string. If parsing fails 0 returned, otherwise number of parsed characters of <code
	>CharType</code
	> is returned.</li
      ></ul
    ><p
    >Generally direct using of <code
      >formatter</code
      > class is preferred when the performance is critical.</p
    ><h2 id="messages-formatting"
    ><a href="#TOC-messages-formatting"
      >Messages Formatting</a
      ></h2
    ><h3 id="introduction-1"
    ><a href="#TOC-introduction-1"
      >Introduction</a
      ></h3
    ><p
    >Messages formatting is probably the most important part of localization&mdash;making your application to speak in users language.</p
    ><p
    >Boost.Locale uses <a href="http://www.gnu.org/software/gettext/"
      >GNU Gettext</a
      > localization model. It is recommended to read general <a href="http://www.gnu.org/software/gettext/manual/gettext.html"
      >documentation</a
      > of GNU Gettext that may be out of scope of this document.</p
    ><p
    >The model is following:</p
    ><ul
    ><li
      ><p
	>First of all our application <code
	  >foo</code
	  > is prepared for localization by calling <code
	  >translate</code
	  > function for each message used in user interface.</p
	><p
	>For example:</p
	><pre
	><code
	  >cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;
</code
	  ></pre
	><p
	>Is converted to</p
	><pre
	><code
	  >cout &lt;&lt; translate(&quot;Hello World&quot;) &lt;&lt; endl;
</code
	  ></pre
	></li
      ><li
      ><p
	>Then all messages are extracted from source code and a special <code
	  >foo.po</code
	  > file is generated that contains all original English strings.</p
	><pre
	><code
	  >...
msgid &quot;Hello World&quot;
msgstr &quot;&quot;
...
</code
	  ></pre
	></li
      ><li
      ><p
	><code
	  >foo.po</code
	  > file is translated for target supported locales: for example <code
	  >de.po</code
	  >, <code
	  >ar.po</code
	  >, <code
	  >en_CA.po</code
	  >, <code
	  >he.po</code
	  >.</p
	><pre
	><code
	  >...
msgid &quot;Hello World&quot;
msgstr &quot;&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;&quot;
</code
	  ></pre
	><p
	>And then compiled to binary <code
	  >mo</code
	  > format and stored if following file structure:</p
	><pre
	><code
	  >de
de/LC_MESSAGES
de/LC_MESSAGES/foo.mo
en_CA/
en_CA/LC_MESSAGES
en_CA/LC_MESSAGES/foo.mo
...
</code
	  ></pre
	><p
	>When application starts. It loads required dictionaries, and when <code
	  >translate</code
	  > function is called and the message is written to an output stream dictionary lookup is performed and localized message is written out.</p
	></li
      ></ul
    ><h3 id="loading-dictionaries"
    ><a href="#TOC-loading-dictionaries"
      >Loading dictionaries</a
      ></h3
    ><p
    >All the dictionaries are loaded by generator class. So, in order to use localized strings in the application you need to specify following:</p
    ><ol class="decimal"
    ><li
      >The search path of the dictionaries</li
      ><li
      >The application domain (or name)</li
      ></ol
    ><p
    >It is done by calling following member functions of <code
      >generator</code
      > class:</p
    ><ul
    ><li
      ><p
	><code
	  >void add_messages_path(std::string const &amp;path)</code
	  >&mdash;add the root path where the dictionaries are placed.</p
	><p
	>For example: if the dictionary is placed at <code
	  >/usr/share/locale/ar/LC_MESSAGES/foo.mo</code
	  >, then path should be <code
	  >/usr/share/locale</code
	  >.</p
	></li
      ><li
      ><p
	><code
	  >void add_messages_domain(std::string const &amp;domain)</code
	  >&mdash;add the domain (name) of the application. In the above case it would be &ldquo;foo&rdquo;.</p
	></li
      ></ul
    ><p
    >At least one domain and one path should be specified in order to load dictionaries.</p
    ><p
    >For example, our first fully localized program:</p
    ><pre
    ><code
      >#include &lt;boost/locale.hpp&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace boost::locale;

int main()
{
    generator gen;

    // Specify location of dictionaries
    gen.add_messages_path(&quot;.&quot;);
    gen.add_messages_domain(&quot;hello&quot;);

    // Generate locales and imbue them to iostream
    locale::global(gen(&quot;&quot;));
    cout.imbue(locale());

    // Display a message using current system locale
    cout &lt;&lt; translate(&quot;Hello World&quot;) &lt;&lt; endl;
}
</code
      ></pre
    ><h3 id="message-translation"
    ><a href="#TOC-message-translation"
      >Message Translation</a
      ></h3
    ><p
    >These are basic translation functions</p
    ><ul
    ><li
      ><code
	>message translate(char const *msg)</code
	>&mdash;create localized message from id <code
	>msg</code
	>. <code
	>msg</code
	> is <strong
	>not</strong
	> copied</li
      ><li
      ><code
	>message translate(std::string const &amp;msg)</code
	>&mdash;create localized message from id <code
	>msg</code
	>. <code
	>msg</code
	> is copied.</li
      ><li
      ><code
	>message translate(char const *single,char const *plural)</code
	>&mdash;create localized plural message with <code
	>signle</code
	> and <code
	>plural</code
	> forms for number <code
	>n</code
	>. Strings <code
	>single</code
	> and <code
	>plural</code
	> are <strong
	>not</strong
	> copied.</li
      ><li
      ><code
	>message translate(std::string const &amp;single,std::string const &amp;plural,int n)</code
	>&mdash;create localized plural message with <code
	>signle</code
	> and <code
	>plural</code
	> forms for number <code
	>n</code
	>. Strings <code
	>single</code
	> and <code
	>plural</code
	> are copied.</li
      ></ul
    ><p
    >These functions return special Proxy object of type <code
      >message</code
      >. It holds all required information for string formatting. When this object is written to an output <code
      >iostream</code
      > it performs dictionary lookup of the id using locale imbued in <code
      >iostream</code
      >. If the message is found in the dictionary is written to the output stream, otherwise the original string is written to the stream.</p
    ><p
    ><strong
      >Notes:</strong
      ></p
    ><ul
    ><li
      ><p
	><code
	  >message</code
	  > can be implicitly converted to each type of supported strings: (i.e. <code
	  >std::string</code
	  >, <code
	  >std::wstring</code
	  > etc.) using global locale:</p
	><pre
	><code
	  >std::wstring msg = translate(&quot;Do you want to open the file?&quot;);
</code
	  ></pre
	></li
      ><li
      ><p
	><code
	  >message</code
	  > can be explicitly converted to string using <code
	  >str&lt;CharType&gt;</code
	  > member function specific locale.</p
	><pre
	><code
	  >std::string msg = translate(&quot;Do you want to open the file?&quot;).str&lt;wchar_t&gt;(some_locale)
</code
	  ></pre
	></li
      ></ul
    ><p
    >This allows postpone translation of the message to the place where translation is actually needed, even to different locale targets.</p
    ><pre
    ><code
      >std::ofstream en,ja,he,de,ar;
std::wfstream w_ar;

void send_to_all(message const &amp;msg)
{
    en &lt;&lt; msg;
    ja &lt;&lt; msg
    he &lt;&lt; msg;
    de &lt;&lt; msg;
    ar &lt;&lt; msg;
    w_ar &lt;&lt; ms;
}

main()
{
    ...
    send_to_all(translate(&quot;Hello World&quot;));
}
</code
      ></pre
    ><h3 id="plural-forms"
    ><a href="#TOC-plural-forms"
      >Plural Forms</a
      ></h3
    ><p
    >GNU Gettext catalogs has simple, robust and yet powerful plural forms support. It is recommended to read some original GNU documentation <a href="http://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms"
      >there</a
      >.</p
    ><p
    >Let&rsquo;s try to solve a simple problem, display a message to user:</p
    ><pre
    ><code
      >if(files == 1)
    cout &lt;&lt; translate(&quot;You have 1 file in the directory&quot;) &lt;&lt; endl;
else
cout &lt; format(translate(&quot;You have {1} files in the directory&quot;)) % files &lt;&lt; endl;
</code
      ></pre
    ><p
    >This quite simple task becomes quite complicated when we deal with language other then English. Many languages have more then two plural forms. For example, in Hebrew there are special forms for single, double, plural, and plural above 10. They can&rsquo;t be distinguished by simple rule &ldquo;<code
      >n</code
      > is 1 or not&rdquo;.</p
    ><p
    >The correct solution is:</p
    ><pre
    ><code
      >cout &lt;&lt; format(tranlsate(&quot;You have 1 file in the directory&quot;,You have {1} files in the directory&quot;,files)) % files &lt;&lt; endl;
</code
      ></pre
    ><p
    >Where translate receives single, plural form of original string and the number it should be formatted for. On the other side, special entry in the dictionary specifies the rule to choose the correct plural form in the specific language, for example, for Slavic languages family there exist 3 plural forms, that can be chosen using following equation:</p
    ><pre
    ><code
      >plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2;
</code
      ></pre
    ><p
    >Such equation is written in the dictionary and it is evaluated during translation supplying the correct form. For more detailed information please refer to GNU Gettext: <a href="http://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms"
      >11.2.6 Additional functions for plural forms</a
      >.</p
    ><h3 id="adding-context-information"
    ><a href="#TOC-adding-context-information"
      >Adding context information</a
      ></h3
    ><p
    >The GNU Gettext model assumes that same source messages are translated to exactly same localized messages, but this may be wrong. For example a button label &ldquo;open&rdquo; is translated to &ldquo;öffnen&rdquo; in context of &ldquo;opening file&rdquo; or to &ldquo;aufbauen&rdquo; in context of opening internet connection in German.</p
    ><p
    >Is such cases it is useful to add some context information to the original string by adding a comment.</p
    ><pre
    ><code
      >button-&gt;setLabel(translate(&quot;#File#open&quot;));
</code
      ></pre
    ><p
    >The comment is placed between first and the following hash symbol&mdash;&lsquo;#&rsquo;. The comment is always extracted from the original string and not displayed, however it is a part of string identification. Translator should discard such comment and translate only &ldquo;open&rdquo; string.</p
    ><p
    >For example, this how <code
      >po</code
      > file is expected to look like:</p
    ><pre
    ><code
      >msgid &quot;#File#open&quot;
msgstr &quot;öffnen&quot;

msgid &quot;#Internet Connection#open&quot;
msgstr &quot;aufbauen&quot;
</code
      ></pre
    ><p
    >In order to insert &lsquo;#&rsquo; as fist symbol you may just use double hash string, for example:</p
    ><pre
    ><code
      >cout&lt;&lt; translate(&quot;$ - Dollar symbol&quot;) &lt;&lt; endl
    &lt;&lt; translate(&quot;## - Hash symbol&quot;) &lt;&lt; endl;
</code
      ></pre
    ><p
    ><strong
      >Note:</strong
      > Hash based comments are extension of the GNU Gettext library.</p
    ><h3 id="working-with-multiple-messages-domains"
    ><a href="#TOC-working-with-multiple-messages-domains"
      >Working with multiple messages domains</a
      ></h3
    ><p
    >In some cases it is useful to work with multiple domains, for example if application consists of several independent modules, it may have several domains. For example, if application consists of modules &ldquo;foo&rdquo;, &ldquo;bar&rdquo; it is possible to specify which dictionary should be used.</p
    ><p
    >There are two ways of using non-default domains:</p
    ><ul
    ><li
      ><p
	>When working with <code
	  >iostream</code
	  >, it is possible to use parametrized manipulator <code
	  >as::domain(std::string const &amp;)</code
	  > that allows switching domains in streams:</p
	><pre
	><code
	  >cout &lt;&lt; as::domain(&quot;foo&quot;) &lt;&lt; translate(&quot;Hello&quot;) &lt;&lt; as::domain(&quot;bar&quot;) &lt;&lt; translate(&quot;Hello&quot;);
// First translation is taken from dictionary foo and other from dictionary bar
</code
	  ></pre
	></li
      ><li
      ><p
	>It is possible to specify domain explicitly when converting a <code
	  >message</code
	  > object to string:</p
	><pre
	><code
	  >std::wstring foo_msg = translate(&quot;Hello World&quot;).str&lt;wchar_t&gt;(&quot;foo&quot;);
std::wstring bar_msg = translate(&quot;Hello World&quot;).str&lt;wchar_t&gt;(&quot;bar&quot;);
</code
	  ></pre
	></li
      ></ul
    ><h3 id="questions-and-answers"
    ><a href="#TOC-questions-and-answers"
      >Questions and Answers</a
      ></h3
    ><ul
    ><li
      ><p
	>Do I need GNU Gettext to use Boost.Locale?</p
	><p
	>Boost.Locale provides a run-time environment to load and use GNU Gettext message catalogs, but it does not provide tools for generation, translation, compilation and managment of these catalogs. Boost.Locale only reimplements GNU Gettext libintl.</p
	><p
	>You would probably need:</p
	><ol class="decimal"
	><li
	  >Boost.Locale itself&mdash;for runtime.</li
	  ><li
	  >A tool for extracting strings from source code, and managing them: GNU Gettext provides good tools, but other implementations available as well.</li
	  ><li
	  >A good translation program like <a href="http://www.poedit.net/"
	    >Poedit</a
	    > or <a href="http://kbabel.kde.org/"
	    >KBabel</a
	    >.</li
	  ></ol
	></li
      ><li
      ><p
	>Is there any reason to prefer Boost.Locale implementation to original GNU Gettext runtime library? In any case I would probably need some of GNU tools.</p
	><p
	>There are two important differences between GNU Gettext runtime library and Boost.Locale implementation:</p
	><ol class="decimal"
	><li
	  >GNU Gettext runtime supports only one locale per-process. It is not thread safe to use multiple locales and encodings in same process. This is perfectly fine for applications that interact directly with single user like most GUI applications, but this is very problematic for services.</li
	  ><li
	  >GNU Gettext API supports only 8-bits encoding making it irrelevant in environments that use natively wide strings.</li
	  ></ol
	></li
      ></ul
    ><h2 id="code-page-conversions"
    ><a href="#TOC-code-page-conversions"
      >Code-page conversions</a
      ></h2
    ><p
    >Boost.Locale provides codepage conversion facets based on <code
      >std::codecvt</code
      > facet. This allows converting between wide characters encoding and 8-bit encodings like UTF&ndash;8, ISO&ndash;8859 or Shift-JIS encodings.</p
    ><p
    >Most of compilers provide such facets, but:</p
    ><ul
    ><li
      >Under Windows MSVC does not support UTF&ndash;8 encodings at all.</li
      ><li
      >Under Linux the encodings are supported only if required locales are generated. For example it may be impossible to create <code
	>he_IL.CP1255</code
	> locale even when <code
	>he_IL</code
	> locale is available.</li
      ></ul
    ><p
    >Thus Boost.Locale provides an option to generate code-page conversion facets for using it with Boost.Iostreams filters or <code
      >std::wfstream</code
      >.</p
    ><p
    ><strong
      >Limitations:</strong
      ></p
    ><ol class="decimal"
    ><li
      ><p
	>Standard does not provides any useful information about <code
	  >std::mbstate_t</code
	  > type that should be used for saving intermediate code-page conversion states. It leave the definition the compiler implementation making it impossible to reimplement <code
	  >std::codecvt&lt;wchar_t,char,mbstate_t&gt;</code
	  > to any stateful encodings. Thus. Boost.Locae <code
	  >codecvt</code
	  > facet implementation may be used only with stateless encodings like UTF&ndash;8, ISO&ndash;8859, Shift-JIS, but not with stateful encodings like UTF&ndash;7 or SCSU.</p
	></li
      ><li
      ><p
	>Standard requires that code page translation can be done by translating each wide character independently. This is not a problem for most fixed width encodings like ISO&ndash;8859 family, and this is not a problem when <code
	  >wchar_t</code
	  > represents a single code point, i.e.<code
	  >sizeof(wchar_t)=4</code
	  > which is true for most POSIX platforms.</p
	><p
	>But under Windows, <code
	  >sizeof(wchar_t)=2</code
	  >, and this it can represent only a single character in Base Multilingual Plane (BMP) where characters with code points above <code
	  >0xFFFF</code
	  > are represented using surrogate pairs. Because, the conversion should be stateless (above limitation) and when <code
	  >wchar_t</code
	  > can&rsquo;t represent single Unicode character, only UCS&ndash;2 encoding is supported, <code
	  >codecvt</code
	  > would fail on surrogate characters of UTF&ndash;16 strings.</p
	><p
	>Same is valid for C++0x <code
	  >char16_t</code
	  > base streams.</p
	></li
      ></ol
    ><p
    >So, if your system supports required encoding, it would be better to use it directly instead of Boost.Locale facet.</p
    ><p
    ><strong
      >General Recommendation:</strong
      > Prefer Unicode UTF&ndash;8 encoding for <code
      >char</code
      > based strings and files in your application.</p
    ><h2 id="boundary-analysis"
    ><a href="#TOC-boundary-analysis"
      >Boundary analysis</a
      ></h2
    ><p
    >Boost.Locale provides boundary analysis tool allowing to split the text into characters, words, sentences and find appropriate places for line breaks.</p
    ><p
    ><strong
      >Note:</strong
      > Characters are not equivalent to Unicode code points. For example a Hebrew word Shalom&mdash;&ldquo;&#1513;&#1464;&#1500;&#1493;&#1465;&#1501;&rdquo; consists of 4 characters and 6 Unicode points, where two code points are used for vowels (diacritical marks).</p
    ><p
    >Boundary analysis is done by creating an index of break points. <code
      >boost::locale::boundary::index_type</code
      >, which is <code
      >std::vector&lt;boundary::break_info&gt;</code
      >. The index is created my calling static member function <code
      >map</code
      > of <code
      >boost::locale::boundary</code
      > class.</p
    ><p
    >Each vector element <code
      >break_info</code
      > has members:</p
    ><ul
    ><li
      ><code
	>offset</code
	>&mdash;the position of the break in the original text.</li
      ><li
      ><code
	>next</code
	>, <code
	>prev</code
	>&mdash;flags describing the text following break position, used with words boundaries mapping.</li
      ><li
      ><code
	>brk</code
	>&mdash;flags describing a break type&mdash;used with line break boundaries mapping.</li
      ></ul
    ><p
    >For example:</p
    ><pre
    ><code
      >std::string text;
getline(cin,text);
boundary::index_type indx=boundary::map(boundary::character,text);
cout &lt;&lt; translate(&quot;All characters the the sentences are:&quot;) &lt;&lt; endl;
for(unsigned i=0;i&lt;index.size()-1;i++) {
    unsigned char_start = index[i].offset;
    unsigned char_end = index[i].offset;
    cout &lt;&lt; text.substr(char_start,char_end-char_start) &lt;&lt; endl;
}
</code
      ></pre
    ><p
    >Sometimes it is important to find what kind of word break point was found. Using <code
      >next</code
      > and <code
      >prev</code
      > members of <code
      >break_info</code
      > we can figure this out. We can use an &ldquo;or&rdquo; mask of flags that are interested us:</p
    ><ul
    ><li
      ><code
	>number</code
	>&mdash;the word included numericals.</li
      ><li
      ><code
	>letter</code
	>&mdash;the word includes letters.</li
      ><li
      ><code
	>kana</code
	>&mdash;the word includes Kana characters</li
      ><li
      ><code
	>ideo</code
	>&mdash;the word included ideographic characters.</li
      ></ul
    ><p
    >If <code
      >prev</code
      > or <code
      >next</code
      > are 0, that means that the break distinguish between white space or punctuation marks. For example, this how we count all the words in text.</p
    ><pre
    ><code
      >fstream file(&quot;some_text.txt&quot;);
typedef map&lt;string,int,locale&gt; words_type;
words_type words;
// Create a map of number of occurrences of the words using
// collation.
while(!file.eof()) {
    string tmp;
    getline(file,tmp);
    boundary::index_type indx=boundary::map(boundary::word,text);
    for(unsigned i=0;i&lt;indx.size();i++) {
        if( (indx[i].next &amp; (boundary::letter | boundary::kana | boundary::ideo))==0)
            // Ingore non-word and numbers
            continue;
        unsigned word_start = index[i].offset;
        unsigned word_end = index[i].offset;
        string word = tmp.substr(char_start,char_end-char_start);
        if(words.find(word)==word.end())
            word[word]=1;
        else
            word[word]++;
    }
}
for(words_type::const_iterator p=words.begin();p!=words.end();++p) {
    cout &lt;&lt; &quot;Word &quot;&lt;&lt;p-&gt;first&lt;&lt;&quot; had &quot;&lt;&lt;p-&gt;second &lt;&lt;&quot; occurrences &quot;&lt;&lt;end;
}
</code
      ></pre
    ><p
    >The additional member <code
      >brk</code
      > of <code
      >break_info</code
      > structure can be used for testing a type of line-break. It can be tested against a mask of following flags:</p
    ><ul
    ><li
      ><code
	>soft</code
	>&mdash;the line-break can appear there.</li
      ><li
      ><code
	>hard</code
	>&mdash;the line-break should appear there (for example new-line character found).</li
      ></ul
    ><p
    >An operator <code
      >&lt;</code
      > defined for <code
      >break_info</code
      > structure. It allows using this index in STL algorithms as &ldquo;binary search&rdquo;. For example: cut at most 100 characters of text at word boundary:</p
    ><pre
    ><code
      >boundary::index_type indx=boundary::map(boundary::word,text);
boundary::index_type::iterator p=lower_range(indx.begin(),indx.end(),boundary::break_info(100));
return text.substr(0,p-&gt;offset);
</code
      ></pre
    ><h2 id="localized-text-formatting"
    ><a href="#TOC-localized-text-formatting"
      >Localized Text Formatting</a
      ></h2
    ><p
    >The <code
      >iostream</code
      > manipulators are very useful but when we create a messages to the user, sometimes we need something like old-good <code
      >printf</code
      > or <code
      >boost::format</code
      >.</p
    ><p
    >Unfortunately <code
      >boost::format</code
      > has several limitations in context of localization:</p
    ><ol class="decimal"
    ><li
      >It renders all parameters using global locale rather then target <code
	>ostream</code
	> locale.</li
      ><li
      >It knows nothing about new Boost.Locale manipulators.</li
      ><li
      ><code
	>printf</code
	> like syntax is very limited for formatting of complex localized data, not allowing formatting of dates, time or currency</li
      ></ol
    ><p
    >Thus new class <code
      >boost::locale::format</code
      > was introduced. For example:</p
    ><pre
    ><code
      >wcout &lt;&lt; wformat(L&quot;Today {1,date} I would meet {2} at home&quot;) % time(0) % name &lt;&lt;endl
</code
      ></pre
    ><p
    >Each format specifier is enclosed withing <code
      >{}</code
      > brackets. Each format specifier is separated with comma &ldquo;,&rdquo; and may have additional option after symbol &lsquo;=&rsquo;. The option may be simple ASCII text or quoted localized text with single quotes &ldquo;&rsquo;&rdquo;. If quote should be inserted to the text, it may be represented with double quote.</p
    ><p
    >For example, format string:</p
    ><pre
    ><code
      >&quot;Ms. {1} had shown at {2,ftime='%I o''clock'} at home. Exact time is {2,time=full}&quot;
</code
      ></pre
    ><p
    >The syntax can be described with following grammar:</p
    ><pre
    ><code
      >format : '{' parameters '}'
parameters: parameter | parameter ',' parameters;
parameter : key [&quot;=&quot; value] ;
key : [0-9a-zA-Z&lt;&gt;] ;
value : ascii-string-excluding-&quot;}&quot;-and=&quot;,&quot; | local-string ; 
local-string : quoted-text | quoted-text local-string;
quoted-text : '[^']*' ;
</code
      ></pre
    ><p
    >Following format key-value pairs are supported:</p
    ><ul
    ><li
      ><code
	>[0-9]+</code
	>&mdash;digits, the index of formatted parameter&mdash;mandatory key.</li
      ><li
      ><p
	><code
	  >num</code
	  > or <code
	  >number</code
	  >&mdash;format a number. Optional values are:</p
	><ul
	><li
	  ><code
	    >hex</code
	    >&mdash;display hexadecimal number</li
	  ><li
	  ><code
	    >oct</code
	    >&mdash;display in octal format</li
	  ><li
	  ><code
	    >sci</code
	    > or <code
	    >scientific</code
	    >&mdash;display in scientific format</li
	  ></ul
	>For example <code
	>number=sci</code
	></li
      ><li
      ><p
	><code
	  >cur</code
	  > or <code
	  >currency</code
	  >&mdash;format currency. Optional values are:</p
	><ul
	><li
	  ><code
	    >iso</code
	    >&mdash;display using ISO currency symbol.</li
	  ><li
	  ><code
	    >nat</code
	    > or <code
	    >national</code
	    >&mdash;display using national currency symbol.</li
	  ></ul
	></li
      ><li
      ><code
	>per</code
	> or <code
	>percent</code
	>&mdash;format percent value.</li
      ><li
      ><p
	><code
	  >date</code
	  >, <code
	  >time</code
	  > , <code
	  >datetime</code
	  > or <code
	  >dt</code
	  >&mdash;format date, time or date and time. Optional values are:</p
	><ul
	><li
	  ><code
	    >s</code
	    > or <code
	    >short</code
	    >&mdash;display in short format</li
	  ><li
	  ><code
	    >m</code
	    > or <code
	    >medium</code
	    >&mdash;display in medium format.</li
	  ><li
	  ><code
	    >l</code
	    > or <code
	    >long</code
	    >&mdash;display in long format.</li
	  ><li
	  ><code
	    >f</code
	    > or <code
	    >full</code
	    >&mdash;display in full format.</li
	  ></ul
	></li
      ><li
      ><code
	>ftime</code
	> with string (quoted) parameter&mdash;display as with <code
	>strftime</code
	> see, <code
	>as::ftime</code
	> manipulator</li
      ><li
      ><code
	>spell</code
	> or <code
	>spellout</code
	>&mdash;spell the number.</li
      ><li
      ><code
	>ord</code
	> or <code
	>ordinal</code
	>&mdash;format ordinal number (1st, 2nd&hellip; etc)</li
      ><li
      ><code
	>left</code
	> or <code
	>&lt;</code
	>&mdash;align to left.</li
      ><li
      ><code
	>right</code
	> or <code
	>&gt;</code
	>&mdash;align to right.</li
      ><li
      ><code
	>width</code
	> or <code
	>w</code
	>&mdash;set field width (requires parameter).</li
      ><li
      ><code
	>precision</code
	> or <code
	>p</code
	>&mdash;set precision (requires parameter).</li
      ><li
      ><p
	><code
	  >locale</code
	  >&mdash;with parameter&mdash;switch locale for current operation. This command generates locale with formatting facets giving more fine grained control of formatting. For example:</p
	><pre
	><code
	  >cout &lt;&lt; format(&quot;This article was published at {1,date=l} (Gregorian) {1,locale=he_IL@calendar=hebrew,date=l} (Hebrew)&quot;) % date;
</code
	  ></pre
	></li
      ></ul
    ><p
    >The constructor of <code
      >format</code
      > class may receive an object of type <code
      >message</code
      > allowing easier integration with localized messages. For example:</p
    ><pre
    ><code
      >cout&lt;&lt; format(tranlsate(&quot;Adding {1} to {2}, we get {3}&quot;)) % a % b % (a+b) &lt;&lt; endl;
</code
      ></pre
    ><p
    >Formatted string can be fetched directly using <code
      >get(std::locale const &amp;loc=std::locale())</code
      > member function. For example:</p
    ><pre
    ><code
      >std::wstring de = (wformat(tranlsate(&quot;Adding {1} to {2}, we get {3}&quot;)) % a % b % (a+b)).str(de_locale);
std::wstring fr = (wformat(tranlsate(&quot;Adding {1} to {2}, we get {3}&quot;)) % a % b % (a+b)).str(fr_locale);
</code
      ></pre
    ><p
    ><strong
      >Important Note:</strong
      ></p
    ><p
    >There is one significant difference between <code
      >boost::format</code
      > and <code
      >boost::locale::format</code
      >: Boost.Locale format converts its parameters only when it is written to <code
      >ostream</code
      > or when <code
      >str()</code
      > member function is called. It only saves a references to the objects that can be written to a stream.</p
    ><p
    >This is generally not a problem when all operations are done in one statement as:</p
    ><pre
    ><code
      >cout &lt;&lt; format(&quot;Adding {1} to {2}, we get {3}&quot;) % a % b % (a+b);
</code
      ></pre
    ><p
    >Because temporary value of <code
      >(a+b)</code
      > exists until the format is actually written to the stream. But following code is wrong:</p
    ><pre
    ><code
      >format fmt(&quot;Adding {1} to {2}, we get {3}&quot;);
fmt % a;
fmt % b;
fmt % (a+b);
cout &lt;&lt; fmt;
</code
      ></pre
    ><p
    >Because temporary value of <code
      >(a+b)</code
      > is no longer exists when <code
      >fmt</code
      > is written to the stream. The correct solution would be:</p
    ><pre
    ><code
      >format fmt(&quot;Adding {1} to {2}, we get {3}&quot;);
fmt % a;
fmt % b;
int a_and_b = a+b;
fmt % a_and_b;
cout &lt;&lt; fmt;
</code
      ></pre
    ><h2 id="getting-information-about-current-locale"
    ><a href="#TOC-getting-information-about-current-locale"
      >Getting information about current locale</a
      ></h2
    ><p
    ><code
      >std::locale::name</code
      > function provides quite limited information about locale. Thus additional facet was created for giving more precise information: <code
      >boost::locale::info</code
      >. It has following member functions:</p
    ><ul
    ><li
      ><code
	>std::string language()</code
	>&mdash;get the language code of current locale, for example &ldquo;en&rdquo;.</li
      ><li
      ><code
	>std::string country()</code
	>&mdash;get country code of currect locale, for example &ldquo;US&rdquo;.</li
      ><li
      ><code
	>std::string variant()</code
	>&mdash;get variant of currecnt locale, for example &ldquo;euro&rdquo;.</li
      ><li
      ><code
	>std::string encoding()</code
	>&mdash;get charset used for <code
	>char</code
	> based strings, for exaple &ldquo;UTF&ndash;8&rdquo;</li
      ><li
      ><code
	>bool utf8()</code
	>&mdash;fast way to check if the encoding is UTF&ndash;8 encoding.</li
      ></ul
    ><h2 id="working-with-multiple-locales"
    ><a href="#TOC-working-with-multiple-locales"
      >Working with multiple locales</a
      ></h2
    ><p
    >Boost.Locale allows you to work safely with multiple locales in the same process. As we mentioned before, the locale generation process is not a cheap one. Thus, when we work with multiple locales it is recommended to create all used locales at the beginning and then use them.</p
    ><p
    ><code
      >generator</code
      > class has member function <code
      >preload</code
      > that allows you create locale and put it into cache. Then, next time you create locale, if it is exists it would be fetched from the existing preloaded locale set.</p
    ><p
    >For example:</p
    ><pre
    ><code
      >generator gen;
gen.octet_encoding(&quot;UTF-8&quot;);
gen.preload(&quot;en_US&quot;);
gen.preload(&quot;de_DE&quot;);
gen.preload(&quot;ja_JP&quot;);
// Create all locales

std::locale en=gen(&quot;en_US&quot;); 
// Fetch existing locale from cache
std::locale ar=get(&quot;ar_EG&quot;);
// Because ar_EG not in cache, new locale is generated (but not cached)
</code
      ></pre
    ><p
    >Then these locales can be imbued to <code
      >iostreams</code
      > or used directly as parameters in various functions.</p
    ><h1 id="recommendations-and-myths"
    ><a href="#TOC-recommendations-and-myths"
      >Recommendations and Myths</a
      ></h1
    ><h2 id="recommendations"
    ><a href="#TOC-recommendations"
      >Recommendations</a
      ></h2
    ><ul
    ><li
      >1st and most important recommendation: prefer UTF&ndash;8 encoding for narrow strings&mdash;it represents all supported Unicode characters and most convenient for general use then other encodings like Latin1.</li
      ><li
      >Remember, there are many different cultures, you may assume very few about possible user language. Calendar may not have &ldquo;January&rdquo;, it may be not possible to convert integer numbers using simple <code
	>atoi</code
	> because they may not use &ldquo;ordinary&rdquo; digits 0..9 at all, you may not assume that &ldquo;space&rdquo; characters are frequent because in Chinese space do not separates different words. The text may be written from Right-to-Left or from Up-to-Down and so far.</li
      ><li
      >Using message formatting try to provide as more context information as you can. Prefer translating entire sentences over short word. When translating words, <strong
	>always</strong
	> add some context information.</li
      ></ul
    ><h2 id="myths"
    ><a href="#TOC-myths"
      >Myths</a
      ></h2
    ><p
    ><strong
      >In order to use Unicode in my application I should use wide strings anywhere.</strong
      ></p
    ><p
    >Unicode property is not limited to wide strings, in fact both <code
      >std::string</code
      > and <code
      >std::wstring</code
      > are absolutely fine to hold and process Unicode text. More then that the semantics of <code
      >std::string</code
      > is much cleaner in multi-platform application, because, if the string is &ldquo;Unicode&rdquo; string then it is UTF&ndash;8. When we talk about &ldquo;wide&rdquo; strings they may be &ldquo;UTF&ndash;16&rdquo; or &ldquo;UTF&ndash;32&rdquo; encoded, depending on platform.</p
    ><p
    >So wide strings may be even less convenient when dealing with Unicode then <code
      >char</code
      > based strings.</p
    ><p
    ><strong
      >UTF&ndash;16 is the best encoding to work with.</strong
      ></p
    ><p
    >There is common assumption that it is one of the best encodings to store information because it gives &ldquo;shortest&rdquo; representation of strings.</p
    ><p
    >In fact, it probably the most error prone encoding to work with it. The biggest issue is code points laying outside of BMP that are represented with surrogate pairs. In fact these characters are very rare and many applications are not tested with them.</p
    ><p
    >For example:</p
    ><ul
    ><li
      >Qt3 could not deal with characters outside of BMP.</li
      ><li
      >Editing a character with codepoint above 0xFFFF shows a not pleasant bug, in order to erase such character you should press backspace twice in Windows Notepad.</li
      ></ul
    ><p
    >So, UTF&ndash;16 can be used for dealing with Unicode, in-facet ICU and may other applications use UTF&ndash;16 as internal Unicode representation, but you should be very careful and never assume one-code-point == one-utf16-character.</p
    ><h1 id="design-rationale"
    ><a href="#TOC-design-rationale"
      >Design Rationale</a
      ></h1
    ><p
    ><strong
      >Why is it needed?</strong
      ></p
    ><p
    >Why do we need localization library, standard C++ facets (should) provide most of required functionality:</p
    ><ul
    ><li
      >Case conversion is done using <code
	>std::ctype</code
	> facet</li
      ><li
      >Collation is supported by <code
	>std::collate</code
	> and has nice integration with <code
	>std::locale</code
	></li
      ><li
      >There are <code
	>std::num_put</code
	>, <code
	>std::num_get</code
	>, <code
	>std::money_put</code
	>, <code
	>std::money_get</code
	>, <code
	>std::time_put</code
	> and <code
	>std::time_get</code
	> for numbers, time and currency formatting and parsing.</li
      ><li
      >There are <code
	>std::messages</code
	> class that supports localized message formatting.</li
      ></ul
    ><p
    >So why do we need such library if we have all the functionality withing standard library?</p
    ><p
    >Almost each(!) facet has some flaws in their design:</p
    ><ul
    ><li
      ><p
	><code
	  >std::collate</code
	  > supports only one level of collation, not allowing to choose whether case, accents sensitive or insensitive comparison should be performed.</p
	></li
      ><li
      ><p
	><code
	  >std::ctype</code
	  > that is responsible for case conversion assumes that conversion can be done on per-character base. This is probably correct for many languages but it isn&rsquo;t correct in general case.</p
	><ol class="decimal"
	><li
	  >Case conversion may change string length. For example German word &ldquo;grüßen&rdquo; should be converted to &ldquo;GRÜSSEN&rdquo; in upper case: the letter &ldquo;ß&rdquo; should be converted to &ldquo;SS&rdquo;, but <code
	    >toupper</code
	    > function works on single character base.</li
	  ><li
	  >Case conversion is context sensitive. For example Greek word &ldquo;&#8008;&#916;&#933;&#931;&#931;&#917;&#910;&#931;&rdquo; should be converted to &ldquo;&#8000;&#948;&#965;&#963;&#963;&#949;&#973;&#962;&rdquo; where Greek letter &ldquo;&#931;&rdquo; is converted to &ldquo;&#963;&rdquo; or to &ldquo;&#962;&rdquo;, according to position in the word.</li
	  ><li
	  >Case conversion can not assume that one character is a single code point, which is incorrect for most popular &ldquo;UTF&ndash;8&rdquo; encoding under Linux and &ldquo;UTF&ndash;16&rdquo; encoding under Windows. Where each code-point is represented up to 4 <code
	    >char</code
	    >&rsquo;s in UTF&ndash;8 and up to two <code
	    >wchar_t</code
	    >&rsquo;s under Windows platform. This makes <code
	    >std::ctype</code
	    > totally useless with UTF&ndash;8 encodings.</li
	  ></ol
	></li
      ><li
      ><p
	><code
	  >std::numpunct</code
	  > and <code
	  >std::moneypunct</code
	  > do not specify digits code point for digits representation at all. Thus it is impossible to format number using digits used under Arabic locales, for example: the number &ldquo;103&rdquo; is expected to be displayed as &ldquo;&#1633;&#1632;&#1635;&rdquo; under <code
	  >ar_EG</code
	  > locale.</p
	><p
	><code
	  >std::numpunct</code
	  > and <code
	  >std::moneypunct</code
	  > assume that thousands separator can be represented using a single character. It is quite untrue for UTF&ndash;8 encoding where only Unicode 0&ndash;0x7F range can be represented as single character. As a result, localized numbers can&rsquo;t be represented correctly under locales that use Unicode &ldquo;EN SPACE&rdquo; character for thousands separator, like Russian locale.</p
	><p
	>This actually cause a real bug under GCC where formatting numbers under Russian locale creates invalid UTF&ndash;8 sequences, even thou it is rather GCC bug then real standard flaw.</p
	></li
      ><li
      ><p
	><code
	  >std::time_put</code
	  > and <code
	  >std::time_get</code
	  > have several flows:</p
	><ol class="decimal"
	><li
	  >It assumes that the required calendar is Gregorian calendar, by using <code
	    >std::tm</code
	    > for time representation, ignoring the fact that in many countries dates may be displayed using different calendars.</li
	  ><li
	  >It always uses global time zone not-allowing specification of time zone for formatting&mdash;actually standard <code
	    >std::tm</code
	    > does not include timezone field.</li
	  ><li
	  ><code
	    >std::time_get</code
	    > is not symmetric with <code
	    >std::time_put</code
	    > now allowing parsing dates and times created with <code
	    >std::time_put</code
	    >. This issue is addressed in C++0x and some STL implementation like Apache standard C++ library.</li
	  ></ol
	></li
      ><li
      ><p
	><code
	  >std::messages</code
	  > does not provide support of plural forms making impossible to localize correctly such simple strings like: &ldquo;There are X files in directory&rdquo;.</p
	></li
      ></ul
    ><p
    >Also many features are not really supported by <code
      >std::locale</code
      > at all: timezones mentioned above, text boundary analysis, numbers spelling and many others. So it is clear that standard C++ locales are very problematic for real-world applications of internationalization and localization.</p
    ><p
    ><strong
      >Why to use ICU wrapper instead of ICU?</strong
      ></p
    ><p
    >ICU is very good localization library but it has several serious flaws:</p
    ><ul
    ><li
      >It is absolutely unfriendly to C++ developer. It ignores most of popular C++ idioms: STL, RTTI, exceptions etc. Instead it mostly mimics Java API.</li
      ><li
      >It provides support of only one kind of strings: UTF&ndash;16 strings, when some users may want to use other Unicode encodings. For example for XML, HTML processing UTF&ndash;8 is much more convenient and UTF&ndash;32 easier to use. Also there is no support of &ldquo;narrow&rdquo; encoding that are still very popular like ISO&ndash;8859 encodings family that are useful and applicable for use.</li
      ></ul
    ><p
    >For example: Boost.Locale provides direct integration with <code
      >iostream</code
      > allowing more natural way of data formatting. For example:</p
    ><pre
    ><code
      >cout &lt;&lt; &quot;You have &quot;&lt;&lt;as::currency &lt;&lt; 134.45 &lt;&lt; &quot; at your account at &quot;&lt;&lt;as::datetime &lt;&lt; std::time(0) &lt;&lt; endl;
</code
      ></pre
    ><p
    ><strong
      >Why the ICU API is not exposed to user?</strong
      ></p
    ><p
    >It is true, all ICU API is hidden behind opaque pointers and user have no access to it. This is done for several reasons:</p
    ><ul
    ><li
      >At some point, better localization tools may be accepted by future upcoming C++ standards and thus, they may not use ICU directly.</li
      ><li
      >At some point, there should be a possibility to switch underlying localization engine to other, for example use native operating system API or use some other toolkits like GLib or Qt that provide similar functionality.</li
      ><li
      >Not all localization is done withing ICU. For example, message formatting uses GNU Gettext message catalogs. In future more functionality may be taken from ICU and reimplemented directly in the Boost.Locale library.</li
      ></ul
    ><p
    ><strong
      >Why to use GNU Gettext catalogs for message formatting?</strong
      ></p
    ><p
    >There are many available localization formats, most popular so far are: OASIS XLIFF, GNU gettext po/mo files, POSIX catalogs, Qt ts/tm files, Java properties, Windows resources. However, the last three are popular each one in its specific area, POSIX catalogs are too simple and limited so there are two quite reasonable options:</p
    ><ol class="decimal"
    ><li
      >Standard localization format OASIS XLIFF.</li
      ><li
      >GNU Gettext binary catalogs.</li
      ></ol
    ><p
    >The first one generally seems like more correct localization solution but&hellip; It requires XML parsing for loading documents, it is very complicated format and even ICU requires preliminary compilation of it into ICU resource bundles.</p
    ><p
    >On the other hand:</p
    ><ul
    ><li
      >GNU Gettext binary catalogs have very simple, robust and yet very useful file format.</li
      ><li
      >It is so far the most popular and de-facto standard localization format (at least in Open Source world.)</li
      ><li
      >It has very simple and very powerful support of plural forms.</li
      ><li
      >It uses original English text as key making the process of internationalization much easier. Because at least one basic translation is always available.</li
      ><li
      >There are many tools for editing and managing gettext catalogs like: Poedit, kbabel etc.</li
      ></ul
    ><p
    >So, even thou GNU Gettext mo catalogs format is not officially approved file format:</p
    ><ul
    ><li
      >It is de-facto standard and most popular one.</li
      ><li
      >It implementation is much easier and does not requires XML parsing and validation</li
      ></ul
    ><p
    ><strong
      >Note:</strong
      > Boost.Locale does not use any of GNU Gettext code, it just reimplements tool for reading and using mo-files, getting rid of current biggest GNU Gettext flaw&mdash;thread safety when using multiple locales.</p
    ><p
    ><strong
      >Why a plain number is used for representation of date-time instead of Boost.DateTime date of Boost.DateTime ptime?</strong
      ></p
    ><p
    >There are several reasons:</p
    ><ol class="decimal"
    ><li
      >Gregorian Date is by definition can&rsquo;t be used for representation of locale independent dates, because not all used calendars are Gregorian.</li
      ><li
      ><p
	><code
	  >ptime</code
	  >&mdash;is defiantly could be used unless it had several problems:</p
	><ul
	><li
	  ><p
	    >It is created in GMT or Local time clock, when <code
	      >time()</code
	      > gives a representation that is independent of time zone, usually GMT time, and only then it should be represented in time zone that user requests.</p
	    ><p
	    >The timezone is not a property of time itself, but it is rather the property of time formatting.</p
	    ></li
	  ><li
	  ><p
	    ><code
	      >ptime</code
	      > already defines and <code
	      >operator&lt;&lt;</code
	      > and <code
	      >operator&gt;&gt;</code
	      > for time formatting and parsing.</p
	    ></li
	  ><li
	  ><p
	    >The existing facets for <code
	      >ptime</code
	      > formatting and parsing were not designed the way user can override their behavior. The major formatting and parsing functions are not virtual. It makes impossible reimplementing formatting and parsing functions of <code
	      >ptime</code
	      > unless developers of Boost.DateTime library would decide to change them.</p
	    ><p
	    >Also, the facets of <code
	      >ptime</code
	      > are not &ldquo;correctly&rdquo; designed in terms of devision between formatting information and local information. Formatting information should be stored withing <code
	      >std::ios_base</code
	      > when information about how to format according to the locale should be stored in the facet itself.</p
	    ><p
	    >The user of library should not create new facets in order to change formatting information like: display only date or both date and time.</p
	    ></li
	  ></ul
	></li
      ></ol
    ><p
    >Thus, at this point, <code
      >ptime</code
      > is not supported for formatting localized date and time.</p
    ></body
  ></html
>

